<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
	<script>
		// 프라미스는 객체이다. 
		// 프라미스를 만들려면 아래와 같다.
		let promise = new Promise((resolve, reject) => {
			setTimeout(function(){
				//resolve('OK'); 
				reject('Fail');
			}, 1000);
		}); 
		
		promise
			.then(function(result){
				console.log(result);
			})
			.catch(function(err){
				console.error("요기=>"+err);
			})
		
		// 뉴라는 키워드로 객체를 생성한다. 
		// 프라이므스 객체는 매개변수로 함수를 받는다.
		// 근데, 함수인데도 불구하고 매개값을 두개 받는다.
		// 근데~ 매개변수 resolve 이것이 또 함수이다. 
		
		// Promise는 상태 : pending(처리중에있다, 펜딩) ---> 이게 작업이 잘 끝나면 fulfilled(완료됨)
		// 약속을 잘 지키면 fulfilled된 상태이고, 안되는 상태면 rejected(정상완료안됨, 거절됨) 상태를 가진다. 
		// 정리 => 상태 : pending / fulfilled / rejected
		
		// 이걸 promise라는 변수에 담아보겠다. 
		// 그리고 이 프로미스는 보통 비동기처리를 할때 사용한다. 
		// 그래서 setTimeout(function(){}, 1000);을 써보겠다. 
		/*
		
			setTimeout(function(){
				resolve('OK'); 
			}, 1000);
		   ==> 이말은 어떤함수가 올지는 모르겠지만, resolve에 ok라는 것을 전달하겠다라는 말임 
	
		
		*/
		
		 // then 메소드와 catch 메소드는 promise에 연결해서 사용할수있따. 
		 // promise가 성공할때는 then메소드, 실패하면 catch메소드가 시행
		 // promise는 바로 실행이 되지만 1초뒤에 실행되는 이유는 setTimeout때문이고 성공했을때 실행할 함수에게 OK를 전달하는데
		 // 성공했을때 시행되는게 바로 then 함수이다. 
		
		// 이번에는 실패했을때는 한번 보자. (console로 보기, log말고 error로 콘솔찍으면 붉은색으로 표시됨. 그냥 에러처럼 보여주는 함수이다)
		
		// 그럼 왜 프로미스객체에 then, catch를 사용하느냐? 
		// 비동기함수는 순서가 좀 헷갈린다. 
		/*
		
		let msg = "";
		   fetch('111.do')
		   .then()
		   .then()
		   ....
		   .then()
		   
		   console.log(msg);
		
		이렇게 찍었는데 msg에 아무것도 안찍힌다. 왜냐하면~  순차적으로 실행하는게 아니라 
		나중에 fetch를 실행하기 때문이다. 
		
		*/
		// 그래서 프로미스객체를 사용해서(. then) 비동기식인데도 순차적으로 보이겠다 해서 사용을 하는 거다. 
		// ==> 이걸 사용하지 않으면 콜백지옥~
		// 그래서 이 프로미스가 굉장히 의미가 크다. 비동기식을 순차적으로 실행하게 하기 위해서이다. 
		
		
		
		
		// 그럼에도 불구하고 then()안에 코드를 넣다보니 좀 힘들다....... 
		// 그래서 그 다음에 위의 코드를 좀더 쉽게 이해하기 위해서 탄생한게 'async, await' 방식이다.
				
		// 어싱크 어웨이트는 함수가 아닌 곳에서는 사용할 수 없다. 
		// promise방식을 어싱크 어웨이트 방식으로 한다면~ 
		/*
		
		async function asynFunction(){

		.....
		
		let result = await promise;   --> promise에 await를 붙이는데 프로미스여서 두번 풀어줘야함
		let result2 = await result.json();  
		.....
		let result3 = await result2();
		
		
		}
		// 위와 같이 쓰면 비동기방식임에도 불구하고 기다렸다가(아래쪽코드 실행안하고) 가져오고 아래코드를 사용하게 된다. 
		// 즉, 우리가 원래 알고 있던 코드 방식대로 사용할 수 있다. 
		
		그래서 우리가 사용하는 fetch()... 이게 대표적인 비동기식방식인데 
		이것도 await fetch()... 이런식으로 코드를 바꿀려고 한다. 
		
		
		
		*/
		
		
		
		
		
		
		
		
		
		
		
		
		
	</script>
</body>
</html>